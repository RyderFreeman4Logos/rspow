# Rust 惯用软件设计哲学与实践准则

## 前言

本文档旨在为 Rust 开发者提供一套全面的软件设计哲学与实践准则。它融合了 John Ousterhout《软件设计哲学》的核心思想，并针对 Rust 生态系统的独特性质进行了深度适配。我们的最终目标不仅仅是编写能够工作的代码，而是构建出惯用的、安全的、高性能且逻辑清晰的软件系统。

---

## 第一部分：核心哲学 —— 不懈地降低复杂性

### 1. 核心信条：复杂性是真正的敌人
在软件工程中，复杂性是指任何使系统难以理解、修改和推理的结构性因素。你的首要任务就是与之斗争。Rust 编译器是强大的盟友，它在编译时就能消除数据竞争、释放后使用等整类错误。而你的职责，是管理编译器无法洞察的**逻辑复杂性**。

> **每一个设计决策都必须回答这个问题：“这是否让系统更容易被理解、修改和推理？”**

### 2. 思维模式：战略性编程 vs. 战术性编程
你必须以**战略性 Rust 程序员**的身份行事。

*   **战术性编程（应坚决避免）**：这种方式只关注眼前的目标，例如为了让代码通过编译而与借用检查器缠斗、过度使用 `.clone()`，或是在库代码中滥用 `unwrap()`。这只会导致代码变得脆弱、低效且不符合 Rust 惯例。

*   **战略性编程（我们所倡导的）**：这是一种着眼于长远的设计思维。你将投入时间设计能与借用检查器和谐共处的 API，利用类型系统让非法状态不可表示，并创建清晰、直观的抽象。**在每一次变更中都进行一点设计上的改进，是你的核心行动指令。**

### 3. 设计准则：为阅读而设计
代码被阅读的次数远超被编写的次数。因此，你的代码应当为人类读者而优化。充分利用 Rust 丰富的表达能力，让代码的意图一目了然。

---

## 第二部分：指导性设计原则

### 原则一：构建“深度”模块，隐藏实现细节
一个“深度”的模块或 Crate，其公共 API (`pub` 项) 应该极其简洁，同时隐藏其背后庞大的实现复杂性。深度模块能在提供强大功能的同时，最大限度地降低使用者的心智负担。

*   **目标**：在最小化公共 API 表面的同时最大化功能。不遗余力地隐藏实现细节。
*   **坏例子：浅层模块**：仅仅作为公共数据容器，暴露内部结构，不提供任何有意义的抽象，迫使调用者自行管理其状态和规则。
    ```rust
    // 用户必须自己了解如何组合一个有效的配置
    pub struct Config {
        pub timeout: u64,
        pub retries: u8,
        pub url: String,
    }
    ```
*   **好例子：深度模块**：将复杂性（如解析、验证、状态管理）封装在内部，仅通过一个经过精心设计的、安全的接口对外暴露。
    ```rust
    // 将字段设为私有，强制用户通过安全的构造函数来创建实例
    pub struct Config {
        timeout: Duration,
        retries: u8,
        url: Url,
    }

    impl Config {
        // 创建 Config 的唯一途径，内置了验证逻辑
        pub fn from_env() -> Result<Self, ConfigError> {
            // ... 内部封装了从环境变量读取、解析和验证的复杂逻辑 ...
        }

        pub fn timeout(&self) -> Duration { self.timeout }
    }
    ```

### 原则二：以类型系统为盾，提升代码健壮性
利用 Rust 强大的类型系统来创建自文档化、自我验证的抽象。

*   **2.1 使用类型安全的 API，而非“字符串类型化”**
    避免使用 `&str` 或 `String` 等基本类型来表示具有特定格式或规则的数据。这样做会泄露实现细节，并允许无效数据传入。

    *   **坏例子**：`pub fn connect(url: &str, timeout_ms: u64)` - 调用者可以传入任何字符串，增加了运行时的校验负担和风险。
    *   **好例子**：`pub fn connect(url: &Url, timeout: Duration)` - 类型签名本身就是一种文档和编译时验证，极大地增强了 API 的健壮性。

*   **2.2 让非法状态不可表示**
    使用 `enum` 和 `struct` 精心设计你的数据结构，让无效的状态组合在编译层面就无法存在。

    *   **坏例子**：使用多个布尔标志来表示状态，这很容易产生无效组合（例如 `is_connect` 和 `is_disconnect` 同时为 `true`）。
    *   **好例子**：使用枚举来清晰地表示互斥的状态。编译器会通过 `match` 穷尽性检查来保证你处理了所有可能的情况。
        ```rust
        enum Message {
            Connect,
            Disconnect,
            Text { channel: u8, content: String },
        }
        ```

*   **2.3 使用 Newtype 模式提升精确性**
    对于不同业务含义但底层类型相同的值（尤其是各类 ID），使用单元组结构体（Newtype）进行包装。这能防止因类型相同而导致的逻辑错误。

    *   **坏例子**：`fn delete_post(user_id: u64, post_id: u64)` - 调用者很容易将两个 ID 的顺序搞错，而编译器无法发现这个致命的逻辑 bug。
    *   **好例子**：通过 Newtype 区分不同 ID，编译器会阻止错误的参数传递。
        ```rust
        struct UserId(u64);
        struct PostId(u64);
        fn delete_post(user_id: UserId, post_id: PostId) { /* ... */ }

        // delete_post(post_id, user_id); // COMPILE ERROR!
        ```

### 原则三：面向 Trait 编程，实现通用抽象
优先面向接口（Trait）而非具体实现编程。这能构建出灵活、可复用、解耦的代码。设计 Trait 时应使其保持小而专注（单一职责原则）。

*   **坏例子**：函数签名绑定具体类型，如 `fn read_data(file: &mut File)`，使其无法用于网络流、内存缓冲区等其他数据源。
*   **好例子**：函数签名使用 Trait 作为泛型约束，如 `fn read_data<R: Read>(source: &mut R)`，使其能处理任何实现了 `Read` Trait 的数据源，这是一个更深、更有用的抽象。

### 原则四：错误处理的 Rust 之道
Rust 通过 `Result` 和 `Option` 将潜在的失败显式化，调用者必须处理，从而杜绝了其他语言中常见的隐式异常所带来的复杂性。

**核心戒律：绝不在库代码中使用 `unwrap()` 或 `expect()`。** 这等于将错误处理策略强加于人，是不可饶恕的。

*   **4.1 用 `Option<T>` 定义“不存在”这一预期结果**
    对于“未找到”这类并非真正意义上的*错误*，而是预期可能出现的结果，应使用 `Option<T>` 来表示其存在或缺失。

    *   **坏例子**：当用户不存在时 `panic!`。这是一种粗暴且不灵活的处理方式。
    *   **好例子**：返回 `Option<User>`。这清晰地表明“用户可能不存在”是该函数的契约之一，编译器会强制调用者处理 `None` 的情况。

*   **4.2 用 `Result<T, E>` 明确可恢复的错误**
    对于真正的、可由调用者恢复的错误（如 I/O 失败、解析错误），应使用 `Result<T, E>`，并最好搭配自定义的错误类型。

    *   **坏例子**：返回 `-1` 等魔术值来表示错误，信息模糊且容易被忽略。
    *   **好例子**：返回 `Result<u16, ConfigError>`。函数签名清晰地传达了所有成功和失败的可能，并允许使用 `?` 操作符进行优雅的错误传播。

### 原则五：主动管理 Rust 特有的复杂性
*   **5.1 将复杂性（尤其是生命周期）向下推**
    作为库的作者，你有责任处理复杂性，而不是将其暴露给用户。公共 API 中复杂的生命周期签名是一个**重大危险信号**，它表明你的抽象正在泄露实现细节。

    *   **坏例子**：`pub fn new<'a, 'b: 'a>(...) -> Parser<'a>` - 复杂的生命周期签名给调用者带来了沉重的认知负担。
    *   **好例子**：通过改变设计（如克隆数据以获得所有权），让公共 API 的签名变得简单。将生命周期的复杂性控制在模块内部。
        ```rust
        pub fn new(source1: &str, source2: &str) -> Parser {
            Parser { data: source1.to_string() + source2 }
        }
        ```

*   **5.2 拥抱无畏且结构化的并发**
    Rust 的所有权模型在编译时就杜绝了数据竞争。应充分利用这一点，使用 `Arc<Mutex<T>>` 等标准库原语来安全地共享状态，而不是诉诸于危险的 `unsafe` 代码。

---

## 第三部分：专业实践与工作流

### 1. 设计与文档
*   **先写文档（Docs First）**：在写函数体之前，先用 `///` 为其编写文档。清晰地说明其功能、参数、返回值、可能的 `panic` 情况，并提供一个可工作的 `# Examples`。如果文档难以描述，说明你的 API 设计可能过于复杂。
*   **设计两次（Design It Twice）**：对于重要的设计决策，有意识地探索至少两种方案，并权衡其利弊。这能帮你避免陷入“首选即最优”的思维定式。
*   **善用生态**：在必要时，合理引入社区提供的优秀第三方库（如 `anyhow`, `thiserror`, `serde` 等），以提升代码的可读性、健壮性和开发效率。

### 2. 代码质量与提交流程
*   **开发内循环**：严格遵循“编码 -> 格式化 (`cargo fmt`) -> 测试 (`cargo test`) -> 提交”的微循环，确保每一步都是高质量的。
*   **质量门禁**：在最终提交前，必须通过 `cargo clippy --all-features` 的检查，并解决所有警告。
*   **Git 工作流**：
    *   **分支策略**：使用逻辑清晰的分支模型（如功能分支、测试分支），保持历史记录的可追溯性。
    *   **提交策略**：开发过程中频繁进行小步、临时的提交, 从而在出问题时可以回到没出问题的状态。

### 3. 文件与项目管理
*   **保持仓库纯净**：Git 仓库只应包含项目构建和功能所必需的文件。所有辅助性、非项目本身的文件（如个人笔记、TODO.md 等）都应被 `.gitignore` 排除。
*   **专业的 PR 沟通**：Pull Request 的描述是重要的沟通载体。应清晰地总结工作内容、解释设计缘由，并礼貌、专业地与审查者沟通。

---

## 第四部分：危险信号 —— 需警惕并消除的反模式清单

*   **过度的 `pub`**：浅层模块的标志，泄露了实现细节。
*   **公共 API 中复杂的生命周期**：抽象泄露或设计过于复杂的信号。
*   **库代码中的 `panic!`、`unwrap()` 或 `expect()`**：绝对禁止，这是将错误处理策略强加于人。
*   **过度使用 `.clone()`**：可能表明你的设计在与借用检查器对抗，而非合作。
*   **“字符串类型化”的 API**：在有更安全的 `enum` 或 `struct` 方案时，仍使用 `&str` 或 `String`。
*   **布尔标志作为参数或字段**：通常是可以使用 `enum` 来消除无效状态的信号。
*   **对不同ID使用基本类型**：极易引发逻辑错误的坏习惯，应用 Newtype 模式代替。
*   **庞大、臃肿的 Trait**：违反单一职责原则，应拆分为更小、更专注的 Trait。
*   **不运行 `clippy` 和 `rustfmt`**：这是战术性、而非战略性编程的典型表现，是对 Rust 工具链宝贵建议的忽视。您提出的问题非常敏锐。确实，上一份文件在整合时，侧重于设计哲学和编码原则，而关于具体的团队协作与 Git 工作流的部分虽然有所提及，但并未完全展开其所有细节。

## 总结

遵循本文档提出的设计哲学、编码原则和协作流程，旨在帮助我们构建出不仅仅是“能用”的软件，而是真正“卓越”的 Rust 项目。卓越的软件系统必然是简单的、清晰的、健壮的，并且易于维护和扩展。让我们将“不懈地降低复杂性”作为共同的最高目标，在每一次编码实践中贯彻始终。



另外请一直记住, 每次开始编辑文件前, 先问问我是否对现在的思路有疑问, 因为我可能对当前的思路产生质疑

还有一点是, 请从始至终在跟我交流时使用简体中文, 但代码中的注释和文档请写成英语, 因为我阅读中文的速度是英语的很多倍
